Rules:
1. fetch highest id for given request_id.
2. check current_status column.
3. tokenize it on '_' and get the no of elements.calling this tokenized elements list as 'tel'.
4. if 2 elements, then check if first element of tel and currently_pending_with_role match.
5. return the last digit of the second element of tel. this should be a single value.
6. if 3 or more elements, then check if first element's token is a substring of any item of tel,find it's index say(m).
7. return the last digit of the m element of tel. this should be an array 

Transation : 
1. fetch highest id for given request_id.
2. check current_status column.
3. for given request_id, check if current_status is same for any other row.
4. if yes, then return the rows with same request_id and same current_status.
5. if no, return row with max_id.


Add role:
1. I/P params : request_id
2. Find max_id for request_id.
3. For this max_id fetch Fetch  last_updated_by_role 'A'
4. For this max_id fetch rule_id.
5. Inner join rule_mvc table.
6. Match last_updated_by_role with approver and find level l.
7. Find a approver higher than 1 l.
8. If there is 1 approver as 'B' add to transaction table with current status as 'B0_A1' with currently_pending_with_role as 'B'
9. If there are more than one approvers (say 2 as B and C) add to transaction table with current status as 'B0_C0_A1' with 2 rows. one row will hvae currently_pending_with_role 'b' and other will have 'c'.   

Check for valid last_updated_by_role:
1. i/p last_updated_by_role
2. fetch list of all roles which are at same level of currently_pending_with_role.
3. if currently_pending_with_role which is a list of string does not contain last_updated_by_role, return false


**************************** CREATING A NEW REQUEST ********************************


Initiate a request:
1. Fetch i/p params :
    A. customers a comma seperated string.
    B. consignees a comma seperated string.
    C. endUse a comma seperated string.
    D. plant as a string.
    E. endUseSegment as a substring.
    F. validFrom as a date.
    G. validTo as a date.
    H. paymentTerms as a string.
    I. oneToOneMapping as a boolean.
2. Find current date.
3. Find max_id for request_id.
4. If max_id is not present for current date, then add a row to request table with current date as NRyyyymmdd0001.
5. If max_id is present for current date, then add a row to request table with current date as NRyyyymmdd(max_id+1).    
6. Now we have to push it all in transaction table whose schema is as follows
        1. Customer (single string)
        2. consignees (single string)
        3. endUse (comma seperated string)
        4. plant (single string)
        5. endUseSegment (single string)
        6. validFrom (date)
        7. validTo (date)
        8. paymentTerms (single string)
        9. oneToOneMapping (boolean)
7. If one to one mapping is checked, first csv element of customers and consignees will be mapped. So if there are 2 customers and 2 consignees there will be 2 rows.
8. If one to one mapping isnt checked, all combinations of customers and consignees will be mapped. So if there are 2 customers and 2 consignees there will be 4 rows.


Add price_approval_system_price:
1. Fetch i/p params:
    A. request_id
    B. fsc
    C. grade
    D. grade_type
    E. gsm_range_from
    F. gsm_range_to
    G. agreed_price
    H. special_discount
    I. reel_discount
    J. pack_upcharge
    K. TPC
    L. offline_discount
    M. net_nsr
    N. old_net_nsr
    O. id (Pk) auto increment. 
2. All above params will be added to price_approval_system_price table.
3. Values will be in form of json_array.


Adding to transaction table:    
1.  Fetch AM_id user am_id from user table.
2.  Fetch region_id from user
3.  In given timeframe, return rule_id which exists.
4.  Insert values in transaction table with current_status as 'RM0A1'
    and currently_pending_with as 'RM' and rule_id 
    last_updated_by_role as 'AM' last updated_id as am_id 
    request_id as given request_id and fetch current time


*************************** FETCH REQUEST DETAILS ********************************

1. Pass i/p params as request_id.
2. Fetch all the rows from price_approval_requests table with given request_id.
3. Club all the repeating json into a consolidated json . By this i mean if there are 2 rows with same request_id,
    then club the json of both rows into a single json. If customer in row 1 is c1 and customer in row 2 is c2 return customer as c1,c2
4. Fetch all the rows from price_approval_system_price table with given request_id with maximum id.



**************** HISTORY **************

1. I/P parameters:
    a. Customer ids (comma seperated string values)
    b. Consignee ids (comma seperated string values)
    c. End us id. (single value strig)
    d. plant ids  (comma seperated string values)
    e. grade  (single value string)
2. All the above parameters are optional.
3. Split customer_ids into individual elements. 
4. For each element, find the available ids and request_ids from table price_approval_requests.
5. Repeat the same for consignee, end_use, plants.
6. Take the inresection or the common elements from the above list.
7. Return that common request_id.
8. Fot that request_id, look into table price_approval_requests_price_table and also filter by provided grade.
9. Return the rows with selected_request_id and grade.


************************************DATA TABELE********************************************

1. Consume api : http://localhost:3000/api/data/RM.
2. O/P is 
[
    {
        "request_id": "NR202405170001",
        "consolidatedRequest": {
            "customer_id": "Customer1, Customer2",
            "consignee_id": "Consignee1, Consignee2",
            "plant": "NorthPlant, South Plant",
            "end_use_id": "Paper",
            "end_use_segment_id": "Packaging",
            "payment_terms_id": "30 days",
            "valid_from": "2023-01-01",
            "valid_to": "2023-12-31",
            "mappint_type": "1",
            "req_id": "3, 4",
            "am_id": "",
            "request_name": "NR202405170001"
        },
        "priceDetails": [
            {
                "req_id": "NR202405170001",
                "grade": "Premium",
                "fsc": "Y",
                "grade_type": "TypeA",
                "gsm_range_from": "80",
                "gsm_range_to": "100",
                "agreed_price": "500",
                "special_discount": "10",
                "reel_discount": "5",
                "pack_upcharge": "2.5",
                "tpc": "1.5",
                "offline_discount": "0.5",
                "net_nsr": "470",
                "old_net_nsr": "460",
                "id": "2"
            }
        ]
    }
]
3. Use react-super-responsive-table for populating the data. 
4. Headers of table are data coming from consolidatedRequest.
5. Headers can be choosen or removed by selecting in a dropdown. 
6. There should be a search functionality.
7. There should be a sort functionality. 




Fetch customers:

1. Fetch all values from customer_table.
2. Fetch Category column.
3. If category contains CUST he is customer.
4. If category contains CONS he is consignee.
5. If category contains end_use it is end_use.
6. API input will be 1 for customer,2 for consigee and 3 for end_use.
7. Return value from 6. 
8. Write nodejs api with mvc and mssql





More information : 
1. Fetch values from role_matrix.
2. 