Rules:
1. fetch highest id for given request_id.
2. check current_status column.
3. tokenize it on '_' and get the no of elements.calling this tokenized elements list as 'tel'.
4. if 2 elements, then check if first element of tel and currently_pending_with_role match.
5. return the last digit of the second element of tel. this should be a single value.
6. if 3 or more elements, then check if first element's token is a substring of any item of tel,find it's index say(m).
7. return the last digit of the m element of tel. this should be an array 

Transation : 
1. fetch highest id for given request_id.
2. check current_status column.
3. for given request_id, check if current_status is same for any other row.
4. if yes, then return the rows with same request_id and same current_status.
5. if no, return row with max_id.


Add role:
1. I/P params : request_id
2. Find max_id for request_id.
3. For this max_id fetch Fetch  last_updated_by_role 'A'
4. For this max_id fetch rule_id.
5. Inner join rule_mvc table.
6. Match last_updated_by_role with approver and find level l.
7. Find a approver higher than 1 l.
8. If there is 1 approver as 'B' add to transaction table with current status as 'B0_A1' with currently_pending_with_role as 'B'
9. If there are more than one approvers (say 2 as B and C) add to transaction table with current status as 'B0_C0_A1' with 2 rows. one row will hvae currently_pending_with_role 'b' and other will have 'c'.   

Check for valid last_updated_by_role:
1. i/p last_updated_by_role
2. fetch list of all roles which are at same level of currently_pending_with_role.
3. if currently_pending_with_role which is a list of string does not contain last_updated_by_role, return false


**************************** CREATING A NEW REQUEST ********************************


Initiate a request:
1. Fetch i/p params :
    A. customers a comma seperated string.
    B. consignees a comma seperated string.
    C. endUse a comma seperated string.
    D. plant as a string.
    E. endUseSegment as a substring.
    F. validFrom as a date.
    G. validTo as a date.
    H. paymentTerms as a string.
    I. oneToOneMapping as a boolean.
2. Find current date.
3. Find max_id for request_id.
4. If max_id is not present for current date, then add a row to request table with current date as NRyyyymmdd0001.
5. If max_id is present for current date, then add a row to request table with current date as NRyyyymmdd(max_id+1).    
6. Now we have to push it all in transaction table whose schema is as follows
        1. Customer (single string)
        2. consignees (single string)
        3. endUse (comma seperated string)
        4. plant (single string)
        5. endUseSegment (single string)
        6. validFrom (date)
        7. validTo (date)
        8. paymentTerms (single string)
        9. oneToOneMapping (boolean)
7. If one to one mapping is checked, first csv element of customers and consignees will be mapped. So if there are 2 customers and 2 consignees there will be 2 rows.
8. If one to one mapping isnt checked, all combinations of customers and consignees will be mapped. So if there are 2 customers and 2 consignees there will be 4 rows.


Add price_approval_system_price:
1. Fetch i/p params:
    A. request_id
    B. fsc
    C. grade
    D. grade_type
    E. gsm_range_from
    F. gsm_range_to
    G. agreed_price
    H. special_discount
    I. reel_discount
    J. pack_upcharge
    K. TPC
    L. offline_discount
    M. net_nsr
    N. old_net_nsr
    O. id (Pk) auto increment. 
2. All above params will be added to price_approval_system_price table.
3. Values will be in form of json_array.


Adding to transaction table:    
1.  Fetch AM_id user am_id from user table.
2.  Fetch region_id from user
3.  In given timeframe, return rule_id which exists.
4.  Insert values in transaction table with current_status as 'RM0A1'
    and currently_pending_with as 'RM' and rule_id 
    last_updated_by_role as 'AM' last updated_id as am_id 
    request_id as given request_id and fetch current time


*************************** FETCH REQUEST DETAILS ********************************

1. Pass i/p params as request_id.
2. Fetch all the rows from price_approval_requests table with given request_id.
3. Club all the repeating json into a consolidated json . By this i mean if there are 2 rows with same request_id,
    then club the json of both rows into a single json. If customer in row 1 is c1 and customer in row 2 is c2 return customer as c1,c2
4. Fetch all the rows from price_approval_system_price table with given request_id with maximum id.



**************** HISTORY **************

1. I/P parameters:
    a. Customer ids (comma seperated string values)
    b. Consignee ids (comma seperated string values)
    c. End us id. (single value strig)
    d. plant ids  (comma seperated string values)
    e. grade  (single value string)
2. All the above parameters are optional.
3. Split customer_ids into individual elements. 
4. For each element, find the available ids and request_ids from table price_approval_requests.
5. Repeat the same for consignee, end_use, plants.
6. Take the inresection or the common elements from the above list.
7. Return that common request_id.
8. Fot that request_id, look into table price_approval_requests_price_table and also filter by provided grade.
9. Return the rows with selected_request_id and grade.


************************************DATA TABELE********************************************

1. Consume api : http://localhost:3000/api/data/RM.
2. O/P is 
[
    {
        "request_id": "NR202405170001",
        "consolidatedRequest": {
            "customer_id": "Customer1, Customer2",
            "consignee_id": "Consignee1, Consignee2",
            "plant": "NorthPlant, South Plant",
            "end_use_id": "Paper",
            "end_use_segment_id": "Packaging",
            "payment_terms_id": "30 days",
            "valid_from": "2023-01-01",
            "valid_to": "2023-12-31",
            "mappint_type": "1",
            "req_id": "3, 4",
            "am_id": "",
            "request_name": "NR202405170001"
        },
        "priceDetails": [
            {
                "req_id": "NR202405170001",
                "grade": "Premium",
                "fsc": "Y",
                "grade_type": "TypeA",
                "gsm_range_from": "80",
                "gsm_range_to": "100",
                "agreed_price": "500",
                "special_discount": "10",
                "reel_discount": "5",
                "pack_upcharge": "2.5",
                "tpc": "1.5",
                "offline_discount": "0.5",
                "net_nsr": "470",
                "old_net_nsr": "460",
                "id": "2"
            }
        ]
    }
]
3. Use react-super-responsive-table for populating the data. 
4. Headers of table are data coming from consolidatedRequest.
5. Headers can be choosen or removed by selecting in a dropdown. 
6. There should be a search functionality.
7. There should be a sort functionality. 




Fetch customers:

1. Fetch all values from customer_table.
2. Fetch Category column.
3. If category contains CUST he is customer.
4. If category contains CONS he is consignee.
5. If category contains end_use it is end_use.
6. API input will be 1 for customer,2 for consigee and 3 for end_use.
7. Return value from 6. 
8. Write nodejs api with mvc and mssql


Write to requests_status_mvc
1. Take input as currently_role and region.
2. Take input as action. 1 for approve 2 for rework. 3 for rejected.
3. From region and role, query table rule_mvc.
4. Fetch the level of role associatd with current role name it as l1.
5. If input action is 1 
    a. Add to table requests_status_mvc values status as 0 and pending as l1+1
    b. If l1+1 does not exists make status as 1 and pending with as -1
6. If input action is 3
    a. Add to table requests_status_mvc values status as 3 and rejected by l1.
7. If input action is 2
    a. If current_approver level is 2 make status as 2 and pending with 1
    b. If current_approver level is more than 2 status is and pending with 2. 


************************* Auto populate of pay terms ********************************

1. User will enter a list of customers say (c1,c2,c3)
2. User will enter a list of consignees say (co1,co2,co3)
3. User will enter a list of end_use say (e1,e2,e3)
4. Make all 27 permutations with customers,consignees and end_use and query the table payment_terms_master.
5. If in table payment_terms_master we find record of c1, fetch the payment term. 
6. If in table payment_terms_master we find record of c1 and co1 fetch that payment term.
7. Similarly if If in table payment_terms_master we find record of c1 and co1 and e1 fetch that payment term.
8. Check for all permutation of customer consigee and enduse. 
9. After checking it fetch the lowest payment_terms_id


*********************  NSM - NSM-T **********************
1. Pass grade with descriptionto function filter.
2. Split grade by spaces and focus on first word.
3. For the given grade(first word) fetch the first digit of profit_center
4. Call function http://192.168.13.129:3000/api/fetchValuesByParams which has json o/p as 

[
    {
        "id": 1,
        "params": "NSM       ",
        "value": "2         ",
        "status": 1
    },
    {
        "id": 2,
        "params": "NSM       ",
        "value": "3         ",
        "status": 1
    },
    {
        "id": 3,
        "params": "NSM       ",
        "value": "4         ",
        "status": 1
    }
]
5. For the given grade(first word) fetch the first digit of profit_center match with values available and return the 


************************* Fetch Parent Req Ids **********************
1. We have a table pre_approved_request_status_mvc.
2. Select query on this table with given request_name.
3. Add request_name to a list.
4. Fetch parent_request_name.
5. Add parent_request_name to a list.
5. Replace the first character with 'N' and use it as request name.
6. Fetch its parent_request_name with this request name.
7. Repeat the process till parent_request_name is null.
8. After reaching null, return the list of request_name.

**********************************************************************
