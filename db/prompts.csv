Rules:
1. fetch highest id for given request_id.
2. check current_status column.
3. tokenize it on '_' and get the no of elements.calling this tokenized elements list as 'tel'.
4. if 2 elements, then check if first element of tel and currently_pending_with_role match.
5. return the last digit of the second element of tel. this should be a single value.
6. if 3 or more elements, then check if first element's token is a substring of any item of tel,find it's index say(m).
7. return the last digit of the m element of tel. this should be an array 

Transation : 
1. fetch highest id for given request_id.
2. check current_status column.
3. for given request_id, check if current_status is same for any other row.
4. if yes, then return the rows with same request_id and same current_status.
5. if no, return row with max_id.


Add role:
1. I/P params : request_id
2. Find max_id for request_id.
3. For this max_id fetch Fetch  last_updated_by_role 'A'
4. For this max_id fetch rule_id.
5. Inner join rule_mvc table.
6. Match last_updated_by_role with approver and find level l.
7. Find a approver higher than 1 l.
8. If there is 1 approver as 'B' add to transaction table with current status as 'B0_A1' with currently_pending_with_role as 'B'
9. If there are more than one approvers (say 2 as B and C) add to transaction table with current status as 'B0_C0_A1' with 2 rows. one row will hvae currently_pending_with_role 'b' and other will have 'c'.   

Check for valid last_updated_by_role:
1. i/p last_updated_by_role
2. fetch list of all roles which are at same level of currently_pending_with_role.
3. if currently_pending_with_role which is a list of string does not contain last_updated_by_role, return false



Initiate a request:
1. Fetch i/p params :
    A. customers a comma seperated string.
    B. consignees a comma seperated string.
    C. endUse a comma seperated string.
    D. plant as a string.
    E. endUseSegment as a substring.
    F. validFrom as a date.
    G. validTo as a date.
    H. paymentTerms as a string.
    I. oneToOneMapping as a boolean.
2. Find current date.
3. Find max_id for request_id.
4. If max_id is not present for current date, then add a row to request table with current date as NRyyyymmdd0001.
5. If max_id is present for current date, then add a row to request table with current date as NRyyyymmdd(max_id+1).    
6. Now we have to push it all in transaction table whose schema is as follows
        1. Customer (single string)
        2. consignees (single string)
        3. endUse (comma seperated string)
        4. plant (single string)
        5. endUseSegment (single string)
        6. validFrom (date)
        7. validTo (date)
        8. paymentTerms (single string)
        9. oneToOneMapping (boolean)
7. If one to one mapping is checked, first csv element of customers and consignees will be mapped. So if there are 2 customers and 2 consignees there will be 2 rows.
8. If one to one mapping isnt checked, all combinations of customers and consignees will be mapped. So if there are 2 customers and 2 consignees there will be 4 rows.
